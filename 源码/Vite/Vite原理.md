### 为什么 vite 比传统的打包快

Vite 之所以比传统的打包工具（如 Webpack）更快，主要得益于其创新的架构设计和对现代浏览器特性的深度利用。以下是其核心优势的详细解析：

---

### **1. 基于原生 ES 模块（Native ESM）的开发服务器**

#### **传统工具的问题**：

传统打包工具（如 Webpack）在开发模式下需要将**所有代码打包成一个或多个 Bundle**，才能启动开发服务器。对于大型项目，这一过程可能非常耗时。

#### **Vite 的解决方案**：

Vite 直接在浏览器中运行**原生 ES 模块**，无需预先打包整个应用：

- **按需编译**：浏览器通过 `import` 语句请求模块时，Vite 实时编译并返回单个文件。
- **快速冷启动**：启动时仅需初始化服务器和预构建依赖，几乎瞬间完成。

```javascript
// 浏览器直接请求 ES 模块
import { render } from "/src/main.js";
```

---

### **2. 依赖预构建（Dependency Pre-Bundling）**

#### **传统工具的问题**：

第三方依赖（如 `lodash`）可能包含大量文件或 CommonJS 模块，传统工具每次启动时都需要重新处理这些依赖。

#### **Vite 的优化**：

- **预构建依赖**：首次启动时，使用 `esbuild`（基于 Go 的超快工具）将依赖转换为 ESM 格式，并合并为单个文件。
- **缓存机制**：预构建结果会被缓存，后续启动和模块请求直接复用。

```bash
# 预构建后的依赖文件
/node_modules/.vite/lodash.js
```

---

### **3. 轻量级的热更新（HMR）**

#### **传统工具的问题**：

Webpack 的 HMR 需要重新构建整个模块依赖链，随着项目规模增大，更新速度显著下降。

#### **Vite 的优化**：

- **基于 ESM 的 HMR**：仅需替换发生变更的模块，无需重建整个 Bundle。
- **精准边界更新**：通过浏览器原生 ESM 的模块依赖关系，直接定位并更新受影响的模块。

```javascript
// Vite HMR 示例：仅更新修改的组件
if (import.meta.hot) {
  import.meta.hot.accept("./component.js", (newModule) => {
    // 替换组件逻辑
  });
}
```

---

### **4. 利用 `esbuild` 的极致性能**

#### **传统工具的问题**：

Webpack 使用 JavaScript 编写的转译工具（如 Babel），性能受限于单线程和解释性语言的瓶颈。

#### **Vite 的优化**：

- **`esbuild` 的核心作用**：用于依赖预构建、TypeScript/JSX 转译等任务。
- **性能优势**：`esbuild` 用 Go 编写，多线程并行处理，速度比 JavaScript 工具快 10-100 倍。

---

### **5. 生产构建的优化**

#### **传统工具的问题**：

Webpack 在开发和生产环境使用同一套打包逻辑，无法针对生产环境深度优化。

#### **Vite 的优化**：

- **开发与生产解耦**：
  - 开发环境：基于 ESM 的按需编译。
  - 生产环境：使用 Rollup 进行 Tree-shaking、代码分割等优化。
- **更高效的构建流程**：Rollup 的打包效率通常优于 Webpack。

---

### **6. 对现代浏览器特性的支持**

#### **传统工具的问题**：

Webpack 默认需要兼容旧版浏览器，导致冗余的转译和 Polyfill。

#### **Vite 的优化**：

- **面向现代浏览器**：默认支持原生 ESM、动态导入等特性，减少不必要的转译。
- **按需 Polyfill**：通过 `@vitejs/plugin-legacy` 插件仅为旧浏览器注入 Polyfill。

---

### **性能对比场景**

| **场景**     | **Webpack**           | **Vite**                           |
| ------------ | --------------------- | ---------------------------------- |
| **冷启动**   | 20s+（大型项目）      | <1s（仅启动服务器，按需编译）      |
| **HMR 更新** | 1s-5s（依赖模块数量） | <50ms（直接替换模块）              |
| **依赖处理** | 每次启动重新打包      | 预构建 + 缓存，仅需一次            |
| **生产构建** | 依赖 Webpack 优化     | 使用 Rollup，更高效的 Tree-shaking |

---

### **总结**

Vite 通过以下设计实现速度飞跃：

1. **原生 ESM 开发服务器**：按需编译，避免全量打包。
2. **`esbuild` 预构建依赖**：极速处理第三方模块。
3. **高效的 HMR**：精准更新，减少无效工作。
4. **开发与生产环境分离**：针对性优化，兼顾速度与质量。

这种架构革新使得 Vite 在开发体验上远超传统工具，尤其适合现代前端项目和大型应用。

## 面试要点：

1. Vite 比 webpack 快的原因

   1. 开发环境中，webpack 是先打包在启动开发服务器，而 vite 是直接启动，然后再按需编译依赖文件。
   2. 底层语言的差异，webpack 是基于 node 构建的，而 vite 是基于 esbuild 进行预构建依赖。esbuild 采用的是 go 语言。

   预构建依赖通常指的是在项目启动或构建之前，对项目中所需的依赖项进行预先的处理或构建。这样做的好处在于，当项目实际运行时，可以直接使用这些已经预构建好的依赖，而无需再进行实时的编译或构建，从而提高了应用程序的运行速度和效率。

   3. 热更新的处理
      在 Webpack 中，当一个模块或其依赖的模块内容改变时，需要重新编译这些模块。

      而在 Vite 中，当某个模块内容改变时，只需要让浏览器重新请求该模块即可，这大大减少了热更新的时间。

2. 环境变量的处理方式

vite 自带了 5 种内建变量
import.meta.env.MODE: {string} 应用运行的模式。

import.meta.env.BASE_URL: {string} 部署应用时的基本 URL。他由 base 配置项决定。

import.meta.env.PROD: {boolean} 应用是否运行在生产环境

import.meta.env.DEV: {boolean} 应用是否运行在开发环境

import.meta.env.SSR: {boolean} 应用是否运行在 server 上

3. 开发环境和生产环境的区别

vite 官网强调生产环境下环境变量动态取值写法是无效的

4. 构建优化策略
5. HMR（热模块替换）的工作原理

   1. 创建模块依赖图：建立模块间的依赖变化
   2. 服务端收集更新模块：监听文件变化，确定需要更新的模块
   3. 客户端派发更新：客户端执行文件更新

6. 代理配置的使用场景
